{
  "hash": "b34d662a7a3ed20e7ccde7c3a961ce4c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Download data with R\nexecute: \n eval: true\n---\n\n\n### Set up work directory\n\nWe use library `here` to define relative paths\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::i_am(\"how2/download-with-R.qmd\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/z3529065/proyectos/typology-website/typology-map-info\n```\n\n\n:::\n:::\n\n\n\n## Profile information from OSF\n\nWorkbook with profile content for Ecosystem Functional Groups of the IUCN Global Ecosystem Typology (Level 3 units) available at https://osf.io/4dcea\n\nWe will create a folder for data download from OSF :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout_folder <- here::here(\"gisdata\", \"profiles\")\nif (!dir.exists(out_folder))\n    dir.create(out_folder, recursive = TRUE)\n```\n:::\n\n\nAnd now download the file there\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_url <- \"https://osf.io/download/4dcea/\"\ndest_file <- here::here(out_folder,  \"IUCN-GET-profiles-exported.xlsx\")\nif (!exists(dest_file))\n    download.file(data_url, dest = dest_file)\n```\n:::\n\n\n## Indicative map data download from zenodo\n\nIndicative maps are available from different Zenodo repositories.\n\nWe will use libraries `zen4R` and `parallel`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(zen4R)\nlibrary(parallel)\n```\n:::\n\n\n### Bundle of indicative maps\n\nOne repository holds the bundle of maps in compressed tar archives. This DOI (digital object identifier) automatically resolves to the latest version, but we need to be explicit when we use the parallel download (otherwise it could get stuck in the _first_ DOI):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndoi = \"10.5281/zenodo.3546513\"\nZR <- get_zenodo(doi=doi)\n(newest_doi <- ZR$getLastDOI())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"10.5281/zenodo.10081251\"\n```\n\n\n:::\n:::\n\n\nWe will create a folder for this direct download from zenodo for the latest version of the bundle:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout_folder <- here::here(\"gisdata\", \"indicative-maps-bundle\",\"latest\")\nif (!dir.exists(out_folder))\n    dir.create(out_folder, recursive = TRUE)\n```\n:::\n\n\nThis can be used to download directly to the output folder. Using `options(timeout=500)` will get overwritten by argument, so it is needed to specify an appropriate timeout as an argument.\nFor some reason the parallel download does not work with the `path` argument, so this workaround uses `getwd` and `setwd`:\n\n\n::: {.cell filename='output not shown'}\n\n```{.r .cell-code}\noldwd <- getwd()\nsetwd(out_folder)\ndownload_zenodo(doi=newest_doi,\n    parallel = TRUE, \n    parallel_handler = parLapply, \n    cl = makeCluster(4),\n    timeout = 5000\n)\nsetwd(oldwd)\n```\n:::\n\n\nWe extract maps from the tar archives in a sandbox folder:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworkdir <- here::here(\"sandbox\",\"latest\")\nif (!dir.exists(workdir))\n    dir.create(workdir)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_tar <- here::here(out_folder, \"all-maps-raster-geotiff.tar.bz2\")\nrast_list <- untar(rast_tar, list = TRUE)\nuntar(rast_tar, exdir = workdir)\n```\n:::\n\n\nAnd similarly for the vector data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_tar <- here::here(out_folder, \"all-maps-vector-geojson.tar.bz2\")\nuntar(vect_tar , exdir = workdir)\n```\n:::\n\n\n### Repositories for single EFG maps\n\nMap details are stored in a xml file that is part of the map bundle zenodo download.\n\nCheck the file was downloaded:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_details_file <- paste(out_folder, \"map-details.xml\", sep = \"/\")\n\nfile.exists(map_details_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nWe'll use the `xml2` library to read the xml file\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xml2)\nmap_details <- read_xml(map_details_file)\n```\n:::\n\n\nWe can query map details for an specific map:\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_details |> xml_find_first(\"//Map[@efg_code='T1.1']\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{xml_node}\n<Map efg_code=\"T1.1\" map_code=\"T1.1.web.mix\" map_version=\"v2.0\" update=\"2020-11-08\">\n[1] <Functional_group>T1.1 Tropical/Subtropical lowland rainforests</Function ...\n[2] <Description>Major and minor occurrences were initially identified using  ...\n[3] <Contributors>\\n  <map-contributor>JR Ferrer-Paris</map-contributor>\\n  < ...\n[4] <Dataset-doi>10.5281/zenodo.5090450</Dataset-doi>\n```\n\n\n:::\n:::\n\n\nThe field with doi for the individual map are stored in the `Dataset-doi` tag. We can run a query for all elements containing this tag:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_dois <- xml_find_all(map_details, \"//Dataset-doi\") |> xml_text()\n```\n:::\n\n\nNow we use this list of DOIs to download a copy of each of the repositories containing files for each ecosystem functional group:\n\n\n::: {.cell filename='output not shown'}\n\n```{.r .cell-code}\noldwd <- getwd()\nfor (doi in all_dois) {\n    out_folder <- here::here(\"gisdata\", \"indicative-maps\", doi)\n    if (!dir.exists(out_folder))\n        dir.create(out_folder, recursive = TRUE)\n    setwd(out_folder)\n    mycl <- makeCluster(4)\n    download_zenodo(doi=doi,\n        parallel = TRUE, \n        parallel_handler = parLapply, \n        cl = mycl,\n    timeout = 5000\n    )\n    #stopCluster(cl = mycl)\n    setwd(oldwd)\n}\n```\n:::\n\n\n### Compare downloaded files\n\nNow we have two copies of each map file, one in the sandbox folder (extracted from the map bundle), and one downloaded directly from the corresponding record.\n\nMap version is described in the map attributes in the xml file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_info <-  map_details |> xml_find_first(\"//Map[@efg_code='T1.3']\")\nmap_info |> xml_attrs() \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     efg_code      map_code   map_version        update \n       \"T1.3\" \"T1.3.WM.nwx\"        \"v1.0\"  \"2021-11-26\" \n```\n\n\n:::\n:::\n\n\nThe file extracted from the tar archive uses the same code for the file name:\n\n::: {.cell}\n\n```{.r .cell-code}\nefg_code <- map_info |> xml_attr(\"efg_code\")\nmatch_pattern <- sprintf(\"^%s\", efg_code)\ndir(workdir, pattern = match_pattern)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"T1.3.WM.nwx_v1.0.json\" \"T1.3.WM.nwx_v1.0.tif\" \n```\n\n\n:::\n:::\n\n\nAs well as the file downloaded from the specific repository:\n\n::: {.cell}\n\n```{.r .cell-code}\nds_doi <- map_info |> xml_find_first(\"Dataset-doi\") |> xml_text()\ndownloaded_copy <- here::here(\"gisdata\", \"indicative-maps\", ds_doi)\ndir(downloaded_copy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"README.md\"                         \"T1_3_Trop_montane_rainforests.png\"\n[3] \"T1_3_Trop_montane_rainforests.xml\" \"T1.3.WM.nwx_v1.0.json\"            \n[5] \"T1.3.WM.nwx_v1.0.tif\"             \n```\n\n\n:::\n:::\n\n\n#### Raster maps\n\nLet's double-check, this is the expected file name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraster_name <- \n    sprintf(\"%s_%s.tif\",\n        map_info |> xml_attr(\"map_code\"),\n        map_info |> xml_attr(\"map_version\"))\n```\n:::\n\n\n\nWe'll use the terra library to read the raster file\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nterra 1.7.55\n```\n\n\n:::\n\n```{.r .cell-code}\nrast1 <- terra::rast(paste(workdir, raster_name, sep = \"/\"))\nrast2 <- terra::rast(paste(downloaded_copy, raster_name, sep = \"/\"))\n```\n:::\n\n\nSummary of the raster layer for the first copy:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 20039, 40076, 1  (nrow, ncol, nlyr)\nresolution  : 1000, 1000  (x, y)\nextent      : -20038500, 20037500, -10019500, 10019500  (xmin, xmax, ymin, ymax)\ncoord. ref. : +proj=eqc +lat_ts=0 +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs \nsource      : T1.3.WM.nwx_v1.0.tif \nname        : T1.3.WM.nwx_v1.0 \n```\n\n\n:::\n:::\n\n\nSummary of the raster layer for the second copy:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 20039, 40076, 1  (nrow, ncol, nlyr)\nresolution  : 1000, 1000  (x, y)\nextent      : -20038500, 20037500, -10019500, 10019500  (xmin, xmax, ymin, ymax)\ncoord. ref. : +proj=eqc +lat_ts=0 +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs \nsource      : T1.3.WM.nwx_v1.0.tif \nname        : T1.3.WM.nwx_v1.0 \n```\n\n\n:::\n:::\n\n\nThe raster looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(rast1)\n```\n\n::: {.cell-output-display}\n![](download-with-R_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nCompare this with the thumbnail downloaded from Zenodo: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magick)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLinking to ImageMagick 6.9.12.93\nEnabled features: cairo, fontconfig, freetype, heic, lcms, pango, raw, rsvg, webp\nDisabled features: fftw, ghostscript, x11\n```\n\n\n:::\n\n```{.r .cell-code}\nthmbmap <- dir(downloaded_copy,\"png\", full.names = TRUE)\nraw_img <- image_read(thmbmap)\nimage_ggplot(raw_img)\n```\n\n::: {.cell-output-display}\n![](download-with-R_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n#### Vector map\n\nWe follow similar steps for the vector files. \n\nWe select the map for this functional group using the map_code and map_version from the map details xml:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_name <- \n    sprintf(\"%s_%s.json\",\n        map_info |> xml_attr(\"map_code\"),\n        map_info |> xml_attr(\"map_version\"))\n```\n:::\n\n\nWe can read both directly from the respective folder:\n\n::: {.cell}\n\n```{.r .cell-code}\nvect1 <- terra::vect(paste(workdir, vector_name, sep = \"/\"))\nvect2 <- terra::vect(paste(downloaded_copy, vector_name, sep = \"/\"))\n```\n:::\n\n\nBut notice some differences in the summaries:\n\n::: {.cell}\n\n```{.r .cell-code}\nvect1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 158540, 1  (geometries, attributes)\n extent      : -17770500, 18911500, -3298500, 4351500  (xmin, xmax, ymin, ymax)\n source      : T1.3.WM.nwx_v1.0.json\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       : occurrence\n type        :      <int>\n values      :          2\n                        2\n                        2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvect2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 158540, 1  (geometries, attributes)\n extent      : -17770500, 18911500, -3298500, 4351500  (xmin, xmax, ymin, ymax)\n source      : T1.3.WM.nwx_v1.0.json (T1.3)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       : occurrence\n type        :      <int>\n values      :          2\n                        2\n                        2\n```\n\n\n:::\n:::\n",
    "supporting": [
      "download-with-R_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}